package crediya.authentication.model.constants;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

class DomainErrorMessagesTest {

    @Test
    @DisplayName("Should not be instantiable")
    void shouldNotBeInstantiable() throws NoSuchMethodException {
        Constructor<DomainErrorMessages> constructor = DomainErrorMessages.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        
        assertThatThrownBy(constructor::newInstance)
            .isInstanceOf(InvocationTargetException.class)
            .hasCauseInstanceOf(UnsupportedOperationException.class)
            .hasRootCauseMessage("Utility class");
    }

    @Test
    @DisplayName("Should have correct email validation messages")
    void shouldHaveCorrectEmailValidationMessages() {
        assertThat(DomainErrorMessages.EMAIL_NULL_OR_EMPTY).isEqualTo("cannot be null or empty");
        assertThat(DomainErrorMessages.EMAIL_INVALID_FORMAT).isEqualTo("invalid email format");
    }

    @Test
    @DisplayName("Should have correct salary validation messages")
    void shouldHaveCorrectSalaryValidationMessages() {
        assertThat(DomainErrorMessages.SALARY_NULL).isEqualTo("cannot be null");
        assertThat(DomainErrorMessages.SALARY_BELOW_MINIMUM).isEqualTo("must be at least 0");
        assertThat(DomainErrorMessages.SALARY_ABOVE_MAXIMUM).isEqualTo("must not exceed 15,000,000");
    }

    @Test
    @DisplayName("Should have correct user validation messages")
    void shouldHaveCorrectUserValidationMessages() {
        assertThat(DomainErrorMessages.USER_NULL).isEqualTo("user cannot be null");
    }

    @Test
    @DisplayName("Should have correct business rule messages")
    void shouldHaveCorrectBusinessRuleMessages() {
        assertThat(DomainErrorMessages.EMAIL_ALREADY_REGISTERED).isEqualTo("Email already registered: %s");
    }

    @Test
    @DisplayName("Should have correct validation template")
    void shouldHaveCorrectValidationTemplate() {
        assertThat(DomainErrorMessages.VALIDATION_FAILED_TEMPLATE).isEqualTo("Validation failed for field '%s': %s");
    }

    @Test
    @DisplayName("Should format email already registered message correctly")
    void shouldFormatEmailAlreadyRegisteredMessageCorrectly() {
        String email = "test@example.com";
        String formattedMessage = String.format(DomainErrorMessages.EMAIL_ALREADY_REGISTERED, email);
        assertThat(formattedMessage).isEqualTo("Email already registered: test@example.com");
    }

    @Test
    @DisplayName("Should format validation failed template correctly")
    void shouldFormatValidationFailedTemplateCorrectly() {
        String fieldName = "email";
        String reason = "invalid format";
        String formattedMessage = String.format(DomainErrorMessages.VALIDATION_FAILED_TEMPLATE, fieldName, reason);
        assertThat(formattedMessage).isEqualTo("Validation failed for field 'email': invalid format");
    }

    @Test
    @DisplayName("Should be final class")
    void shouldBeFinalClass() {
        assertThat(DomainErrorMessages.class).isFinal();
    }

    @Test
    @DisplayName("Should have only private constructor")
    void shouldHaveOnlyPrivateConstructor() {
        Constructor<?>[] constructors = DomainErrorMessages.class.getDeclaredConstructors();
        assertThat(constructors).hasSize(1);
        assertThat(constructors[0].getModifiers()).isEqualTo(java.lang.reflect.Modifier.PRIVATE);
    }

    @Test
    @DisplayName("Should have all constants as public static final")
    void shouldHaveAllConstantsAsPublicStaticFinal() {
        java.lang.reflect.Field[] fields = DomainErrorMessages.class.getDeclaredFields();
        
        for (java.lang.reflect.Field field : fields) {
            // Skip synthetic fields that might be generated by the compiler or tools
            if (field.isSynthetic()) {
                continue;
            }
            
            int modifiers = field.getModifiers();
            assertThat(java.lang.reflect.Modifier.isPublic(modifiers))
                .describedAs("Field %s should be public", field.getName())
                .isTrue();
            assertThat(java.lang.reflect.Modifier.isStatic(modifiers))
                .describedAs("Field %s should be static", field.getName())
                .isTrue();
            assertThat(java.lang.reflect.Modifier.isFinal(modifiers))
                .describedAs("Field %s should be final", field.getName())
                .isTrue();
        }
    }
}